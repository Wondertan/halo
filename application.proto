syntax = "proto3";

package consensus;
option go_package = "github.com/cmwaters/consensus";

import "google/protobuf/duration.proto";

// The application supports the relevant business logic that uses the consensus
// engine for decentralized state machine replication. Specifically an application
// must be responsible for at least three things:
//
// 1) Forming and aggregation of transactions which are bundled together in a payload
//    and proposed by the proposer of that round. Applications may also perform
//    transcation dissemination so that all participants are aware of transactions.
//    This is useful to ensure transactions are committed faster and for content
//    addressable payloads which only contain the hashes of transactions.
//
// 2) Validation of proposed data. Specifically this must conform with the coherence
//    property - a correct node shold never propose a transaction that another correct
//    process would deem as invalid. 
//
// 3) Execution (and optionally the persistence) of tranasctions finalized by the
//    consensus engine. For state machine replication, this must be a deterministic
//    process such that all correct processes upon receiving the same transactions will
//    always progress to the same state. One can use hashes as a method to detect non-
//    determinsim.
//
// Additionally, the application ideally has a subcomponent responsible for syncing to 
// the height that the rest of the network is at. This involves the sending of payloads 
// and their respective signatures for other nodes to verify.
service Application {
    rpc Handshake(HandshakeRequest) returns (HandshakeResponse);
    rpc ProposeData(ProposeDataRequest) returns (ProposeDataResponse);
    rpc ValidateData(ValidateDataRequest) returns (ValidateDataResponse);
    rpc FinalizeData(FinalizeDataRequest) returns (FinalizeDataResponse);
}

message HandshakeRequest {
    uint32 version = 1;
}

message HandshakeResponse {
    string chain_id = 1;
    uint64 height = 2;
    uint32 round = 3;
    ValidatorSet validator_set = 4;
    SynchronyParams params = 5;
}

message ProposeDataRequest {
    uint64 height = 1;
}

message ProposeDataResponse {
    repeated bytes data = 1;
}

message ValidateDataRequest {
    uint64 height = 1;
    uint32 round = 2;
    repeated bytes data = 3;
}

message ValidateDataResponse {
    Status status = 1;

    enum Status {
        UNKNOWN = 0;
        ACCEPT = 1;
        REJECT = 2;
    }
}

message FinalizeDataRequest {
    uint64 height = 1;
    repeated bytes signatures = 2;
    repeated bytes data = 3;
    
}

message FinalizeDataResponse {
    repeated ValidatorUpdate validator_updates = 1; 
    SynchronyParams params = 2;
    bool terminate = 3;
}

message ValidatorUpdate {
    bytes pub_key = 1;
    uint64 power = 2;
}

message ValidatorSet {
    repeated Validator validators = 1;
}

message Validator {
    bytes pub_key = 1;
    uint64 voting_power = 2; 
    uint64 proposer_priority = 3;
}

message SynchronyParams {
    // These fields configure the timeouts for the propose step of the Tendermint
    // consensus algorithm: propose is the initial timeout and propose_delta
    // determines how much the timeout grows in subsequent rounds.
    // For the first round, this propose timeout is used and for every subsequent
    // round, the timeout grows by propose_delta.
    //
    // For example:
    // With propose = 10ms, propose_delta = 5ms, the first round's propose phase
    // timeout would be 10ms, the second round's would be 15ms, the third 20ms and so on.
    //
    // If a node waiting for a proposal message does not receive one matching its
    // current height and round before this timeout, the node will issue a
    // nil prevote for the round and advance to the next step.
    google.protobuf.Duration propose       = 1;
    google.protobuf.Duration propose_delta = 2;

    // vote along with vote_delta configure the timeout for both of the prevote and
    // precommit steps of the Tendermint consensus algorithm.
    //
    // These parameters influence the vote step timeouts in the the same way that
    // the propose and propose_delta parameters do to the proposal step.
    //
    // The vote timeout does not begin until a quorum of votes has been received. Once
    // a quorum of votes has been seen and this timeout elapses, Tendermint will
    // procced to the next step of the consensus algorithm. If Tendermint receives
    // all of the remaining votes before the end of the timeout, it will proceed
    // to the next step immediately.
    google.protobuf.Duration vote       = 3;
    google.protobuf.Duration vote_delta = 4;

    // commit configures how long Tendermint will wait after receiving a quorum of
    // precommits before beginning consensus for the next height. This can be
    // used to allow slow precommits to arrive for inclusion in the next height before progressing.
    google.protobuf.Duration commit = 5;

    // bypass_commit_timeout configures the node to proceed immediately to
    // the next height once the node has received all precommits for a block, forgoing
    // the remaining commit timeout.
    // Setting bypass_commit_timeout false (the default) causes Tendermint to wait
    // for the full commit timeout.
    bool bypass_commit_timeout = 6;   
}